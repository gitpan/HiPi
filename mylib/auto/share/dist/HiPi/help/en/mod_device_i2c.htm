
<!-- #define _BUILD_HIPI_WEBDOC -->

<HTML>
<head>
 <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <title>HiPi::Device::I2C</title></head>

<BODY TOPMARGIN=4 BGCOLOR=#FFFFFF TEXT=#000000 VLINK=#0000CC LINK=#0000CC ALINK=#0000CC>
<FONT FACE="Arial, Lucida, Helvetica" >

<TABLE WIDTH="100%" ALIGN=CENTER CELLPADDING=1 CELLSPACING=0>
<TR>
<TD WIDTH="100%" ALIGN=CENTER>


<A HREF="contents.htm"><img align=center src="home.png" BORDER=0 ALT="Contents"></A>


<A HREF="mod_device.htm"><img align=center src="up.png" BORDER=0 ALT="Up"></A>

<A HREF="hipi-device-gpio-pin.htm"><img align=center src="back.png" BORDER=0 ALT="Previous"></A>

<A HREF="mod_device_spi.htm"><img align=center src="forward.png" BORDER=0 ALT="Next"></A>
</TD>
</TR>
<TR>
<TD COLSPAN=2 HEIGHT=2 BGCOLOR="#C0C0C0">
</TD>
</TR>
</TABLE>

<H2>HiPi::Device::I2C</H2><p>The HiPi::Device::I2C module provides access to the kernel driver for the I2C bus.</p>
<p>See : <A HREF="topic_i2cdev.htm">I2C Device Driver</A></p>
<p>The settings for the I2C device can be controlled in the <A HREF="control_app_i2cdev.htm">HiPi Control GUI</A>.</p>
<p>Currently the module only implements the SMBus protocol as this appears to be the most widely supported protocol used on the i2c bus. It is likely that your i2c devices support it.</p>
<p>The following interface modules use HiPi::Device::I2C as a backend and may contain code that helps with your own usage.</p>
<p><A HREF="mod_interface_htadci2c.htm">HiPi::Interface::HTADCI2C</A><br />
<A HREF="mod_interface_mcp23017.htm">HiPi::Interface::MCP23017</A><br />
<A HREF="mod_interface_htbackpackv2.htm">HiPi::Interface::HTBackpackV2</A> <I>( as an optional backend )</I><br />
</p>
<h2>Class Methods</h2>
<h5>HiPi::Device::I2C->load_modules( $forceunload );</h5>
<pre>    Loads the kernel device driver modules for i2c
    i2c_bcm2708
    i2c_dev

    When $forceunload is true, unloads the kernel modules
    first if they are loaded (effectively forces a reload)

    i2c_bcm2708 is loaded with the current baudrate

    Of course, the user the script is running as must have
    root permissions to load and unload kernel modules.</pre>
<h5>HiPi::Device::I2C->unload_modules();</h5>
<pre>    Unloads the kernel device driver modules for i2c
    i2c_bcm2708
    i2c_dev

    Of course, the user the script is running as must have
    root permissions to load and unload kernel modules.</pre>
<h5>HiPi::Device::I2C->get_baudrate();</h5>
<pre>    Returns the current baudrate of a loaded i2c_bcm2708
    module. If the module is not loaded or the process 
    does not have root permissions, returns the current
    default module setting for baudrate.</pre>
<h5>HiPi::Device::I2C->set_baudrate( $baudrate );</h5>
<pre>    Sets the baudrate of the i2c_bcm2708 module. Must
    unload and load the kernel module to do this.

    Of course, the user the script is running as must have
    root permissions to load and unload kernel modules.</pre>
<h5>HiPi::Device::I2C->get_device_list();</h5>
<pre>    Returns an array containing the names of available
    devices. 
    Will normally return ('/dev/i2c-1', '/dev/i2c-0')
</pre>
<h2>Object Constructor and Methods</h2>

<h5>my $dev = HiPi::Device::I2C->new( address => $devaddress );</h5>
<pre>    $devaddress    address of the device ( e.g. 0x20 ) on the
                   default bus. The default bus is determined
                   according to your Pi board revision.
                   revision 1 = /dev/i2c-0
                   revision 2 = /dev/i2c-1
    
    returns a new instance of the HiPi::Device::I2C class.
    
    You can specify which i2c device to use in the constructor if
    you wish using the key 'devicename'.

    my $dev = HiPi::Device::I2C->new( 
        devicename => '/dev/i2c-1',
        address    => 0x28 
    );
</pre>
<h3>SMBus Methods</h3>
<h5>$dev->smbus_write( @params );</h5>
<pre>    The module provides the method smbus_write as 
    a generic call to the main smbus methods. I have
    found it is all I need for all i2c devices
    tested so far.
    
    If @params is a single value, the method calls
    
    $dev->smbus_write_byte($params[0]);

    If @params contains two values, the method calls
    
    $dev->smbus_write_byte_data( @params );

    With three or more values in @params, the method does
    
    my $command = shift @params;
    $dev->smbus_write_i2c_block_data($command, @bytes );</pre>
<h5>$dev->smbus_read( $cmdval, $numbytes );</h5>
<pre>    The module provides the method smbus_read as 
    a generic call to the main smbus methods. I have
    found it is all I need for all i2c devices
    tested so far.
    
    If $cmdval is not defined, the method returns a
    scalar value from
    
    $dev->smbus_read_byte;
    
    If $cmdval is defined but $numbytes is undefined
    or zero, then the method returns a scalar value
    from
    
    $dev->smbus_read_byte_data( $cmdval );

    If $cmdval is defined and $numbytes is greater
    than zero then the method returns an array of
    values from

    $dev->smbus_read_i2c_block_data( $cmdval, $numbytes );</pre>
<h5>$dev->smbus_write_quick($value);</h5>
<pre>    writes $value to the device</pre>
<h5>$dev->smbus_read_byte();</h5>
<pre>    returns the first byte read from the device</pre>
<h5>$dev->smbus_write_byte($value);</h5>
<pre>    writes byte $value to the device</pre>
<h5>$dev->smbus_read_byte_data( $command );</h5>
<pre>    returns byte from the device specifying
    register address in $command;</pre>
<h5>$dev->smbus_write_byte_data( $command, $value );</h5>
<pre>    writes byte $value to the register address specified
    in $command</pre>
<h5>$dev->smbus_read_word_data($command);</h5>
<pre>    reads a word beginning at the device register 
    specified in $command;</pre>
<h5>$dev->smbus_write_word_data($command, $word);</h5>
<pre>    writes a word to the device register 
    specified in $command;</pre>
<h5>$dev->smbus_read_word_swapped($command);</h5>
<pre>    reads a word beginning at the device register 
    specified in $command and swaps the high /low
    bytes in the return value</pre>
<h5>$dev->smbus_write_word_swapped($command, $word);</h5>
<pre>    writes a word to the device register 
    specified in $command after swapping the
    high / low bytes in $word</pre>
<!--<h5>$dev->smbus_process_call($command, $value);</h5>
    Low level command. See the SMBus documentation -->
<h5>$dev->smbus_read_block_data( $command );</h5>
<pre>    Returns an array of values read starting at register
    specified in $command.
    In all devices tested so far I have found it necessary
    to use $dev->smbus_read_i2c_block_data; instead.</pre>
<h5>$dev->smbus_read_i2c_block_data( $command, $numbytes );</h5>
<pre>    returns an array of bytes $numbytes in size reading from
    register specified in $command;</pre>
<h5>$dev->smbus_write_block_data( $command, $arrayref );</h5>
<pre>    Writes all the bytes from array reference $arrayref to
    device specifying the register in $command.
    In all devices tested so far I have found it necessary
    to use $dev->smbus_write_i2c_block_data instead.</pre>
<h5>$dev->smbus_write_i2c_block_data( $command, $arrayref );</h5>
<pre>    Writes all the bytes from array reference $arrayref to
    device specifying the register in $command. 
</pre></FONT>
<br>
<p>
<br>
<hr>
<br>
<center>
<A HREF="contents.htm"><img align=center src="home.png" BORDER=0 ALT="Contents"></A>


<A HREF="mod_device.htm"><img align=center src="up.png" BORDER=0 ALT="Up"></A>

<A HREF="hipi-device-gpio-pin.htm"><img align=center src="back.png" BORDER=0 ALT="Previous"></A>

<A HREF="mod_device_spi.htm"><img align=center src="forward.png" BORDER=0 ALT="Next"></A>
</center>

<HR>
<br>
<center><FONT FACE="Arial, Lucida, Helvetica" size="2" color="#000080">HiPi Modules Copyright &#169; 2013 Mark Dootson</font></center>
</BODY></HTML>
